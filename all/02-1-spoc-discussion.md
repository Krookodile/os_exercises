#lec 3 SPOC Discussion

## 第三讲 启动、中断、异常和系统调用-思考题

## 3.1 BIOS
 1. 比较UEFI和BIOS的区别。
 >  UEFI是在BIOS之后发展起来的一种加载接口，全称“统一的可扩展固件接口”是一种详细描述类型接口的标准。这种接口用于操作系统自动从预启动的操作环境，加载到一种操作系统上。与BIOS显著不同的是，UEFI是用模块化、C语言风格的参数堆栈传递方式、动态链接的形式构建系统，它比BIOS更易于实现，容错和纠错特性也更强，从而缩短了系统研发的时间。此外，BIOS对于不同系统的启动流程标准不能统一支持，而是用UEFI接口能在所有平台上提供一致的操作系统启动服务。

 2. 描述PXE的大致启动流程。
 >  PXE是一种网络启动服务，不同于一般的BIOS，PXE启动是远程启动，是通过本地网卡通迅直接启动远程服务器上的镜像系统,         而不依赖于本地硬盘。

## 3.2 系统启动流程
 1. 了解NTLDR的启动流程。
 
>  NTLDR是NT内核操作系统的启动器，主引导记录在找到NTLDR之后初始化并启动NTLDR，并把系统控制权转移给启动器。之后就开始由    NTLDR组织引导过程。初始引导加载器阶段中，NTLDR将NT系统从计算机的微处理器从实模式转换为32位平面内存模式，再执行适当    的小型文件系统驱动程序识别每一个用NTFS或FAT格式的文件系统分区，在活动分区根目录寻找并加载Boot.ini文件。通过Boot.ini    文件的配置，NTLDR展开之后的启动流程。在处理完boot.ini文件之后，ntldr会启动ntdetect.com程序。在基于X86的系统中，ntde    tect.com会通过调用系统固件程序收集安装的硬件信息，然后由ntdetect.com将收集的计算机硬件信息列表并将列表返回到ntldr。    Ntldr获取从ntdetect.com发来的信息后，将这些信息组织成为内部结构形式，然后由ntldr启动ntoskrnl.exe程序,并将这些信息和    boot.ini文件中的信息，以及注册表中的硬件和软件信息传递给ntoskrnl.exe 程序，即下放给控制权传递给Windows XP内核。
   至此，Ntldr启动任务完成。

 2. 了解GRUB的启动流程。

>  Grub的实质是一个mini os，它拥有shell，支持script，支持特定文件系统。grub由stage1，stage1-5，stage2以及/boot/grub目    录下的诸多文件（包括Grub的配置文件与相关文件系统定义文件等）组成，其核心是stage2，主要功能在于完成操作系统的引导工    作。计算机启动时，BIOS加载硬盘主引导扇区总共512字节的二进制代码，执行IPL，IPL就是存储于446个字节的MBR中，是GRUB的第    一个部分（stage1）。stage1的工作是加载stage1_5（ext3文件系统就是e2fs_stage1_5），它位于0面0道第2扇区开始的十几个扇    区内。stage1_5运行后，就可以识别/boot所在分区的文件系统了。当加载并运行了stage2后grub，会根据menulist或用户输入加载    kernel，然后控制权就转到Linux了。
 
 3. 比较NTLDR和GRUB的功能有差异

>   从功能上说，Grub是一个更加强大的引导管理器。ntldr只是为windows NT系统专门配置的引导文件，而Grub是多系统引导管理器，许多多系统以及linux环境都在使用Grub作为引导。

 4. 了解u-boot的功能。

## 3.3 中断、异常和系统调用比较
 1. 举例说明Linux中有哪些中断，哪些异常？
 2. Linux的系统调用有哪些？大致的功能分类有哪些？  (w2l1)
 
 >  Linux下的系统调用种类繁多，在2.4.4版本中，狭义上的系统调用有244条之多。而广义上的以库函数形式实现的系统调用，可能     根本没有人统计过，至少也是数百条甚至上千条的。
    在常见的系统调用列表中，一般都会按进程控制、文件系统控制、系统控制、内存管理、网络管理、socket控制、用户管理、进程     间通信等方面来列举。这就很好地说明了Linux提供的系统调用功能也大多是按照这八个方面来展开的。系统调用由操作系统核心     提供，运行于核心态。应用程序利用系统调用访问自身无法直接获得的资源，运用这些系统命为上层应用程序提供快捷方便而且安     全可信的支持，并提高效率，优于许多c语言内库中提供的实现。

 ```
  + 采分点：说明了Linux的大致数量（上百个），说明了Linux系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
 1. 以ucore lab8的answer为例，uCore的系统调用有哪些？大致的功能分类有哪些？(w2l1)
 
>   在lab8_result/kern/syscall/syscall.c中，我们可以清楚地看到有22条系统调用。这22条命令主要涉及的功能有进程控制（如fo     rk、exit、exec、getpid）、进程间通信(kill)、系统控制（gettime）、文件系统控制（read、write、dup、getdirentry）、内     存管理（fstat、fsync）等方面。
    基本涵盖了操作系统所必须承载的接口调用，为上层应用调用外部设备资源提供了安全、可靠、高效的系统支持。
 
 
 ```
  + 采分点：说明了ucore的大致数量（二十几个），说明了ucore系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
## 3.4 linux系统调用分析
 1. 通过分析[lab1_ex0](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex0.md)了解Linux应用的系统调用编写和含义。(w2l1)
 

 ```
  + 采分点：说明了objdump，nm，file的大致用途，说明了系统调用的具体含义
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 
 ```
 
 1. 通过调试[lab1_ex1](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex1.md)了解Linux应用的系统调用执行过程。(w2l1)
 

 ```
  + 采分点：说明了strace的大致用途，说明了系统调用的具体执行过程（包括应用，CPU硬件，操作系统的执行过程）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
## 3.5 ucore系统调用分析
 1. ucore的系统调用中参数传递代码分析。
 2. ucore的系统调用中返回结果的传递代码分析。
 3. 以ucore lab8的answer为例，分析ucore 应用的系统调用编写和含义。
 4. 以ucore lab8的answer为例，尝试修改并运行ucore OS kernel代码，使其具有类似Linux应用工具`strace`的功能，即能够显示出应用程序发出的系统调用，从而可以分析ucore应用的系统调用执行过程。
 
## 3.6 请分析函数调用和系统调用的区别
 1. 请从代码编写和执行过程来说明。
 2. 说明`int`、`iret`、`call`和`ret`的指令准确功能
 

